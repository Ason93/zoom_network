function [bbox_targets, src_rois, gt_info, anchors] = rpn_compute_targets_v0( ...
    conf, gt_rois, gt_labels, anchors, im_size_resize)
% output: bbox_targets
%   positive:   [class_label,   regression_label]
%   ignore:     [-2,            zero(regression_label)]
%   negative:   [-1,            zero(regression_label)]
%   gray:       [0,             zero(regression_label)]
% NOTE: gt_rois and anchors are all the resized (say 500 -> 600) results!

if isempty(gt_rois)
    bbox_targets = zeros(size(anchors, 1), 5, 'double');
    bbox_targets(:, 1) = -1;
    return;
end

gt_labels = single(gt_labels);
assert(all(gt_labels > 0));

if conf.revise_boundary_box
    % revise boundary boxes, just keep them!
    [new_anchors, check_] = refine_box(anchors, im_size_resize);
    % overlap between anchors and gt_rois
    ex_gt_overlaps = zeros(size(anchors, 1), size(gt_rois, 1));
    ex_gt_overlaps(check_, :) = boxoverlap(new_anchors, gt_rois);    
    % update anchors also!
    anchors(check_, :) = new_anchors;
else
    % overlap between anchors and gt_rois
    ex_gt_overlaps = boxoverlap(anchors, gt_rois);
    % drop anchors which run out off image boundaries
    if conf.drop_boxes_runoff_image
        contained_in_image = is_contain_in_image(anchors, im_size_resize);
        ex_gt_overlaps(~contained_in_image, :) = 0;
    end
end

% for each anchor, get its max overlap with all gt_rois
[ex_max_overlaps, ex_assignment] = max(ex_gt_overlaps, [], 2);
% for each gt_rois, get its max overlap with anchors,
% this is to ensure each gt has AT LEAST one matching anchor
[gt_max_overlaps, gt_assignment] = max(ex_gt_overlaps, [], 1);
% anchors with gt_max_overlaps may have more than one,
% find them all as gt_best_matches
% NOTE: must have 'gt_ind' here
[gt_best_matches, gt_ind_must_keep_this_var] = find(bsxfun(@eq, ex_gt_overlaps, gt_max_overlaps));

%% chooese fg/bg indices
% both (ex_max_overlaps >= conf.fg_thresh) and gt_best_matches are
% assigned as positive examples
% IMPORTANGT: leave out 'gt_best_matches'
% fg_inds = unique([find(ex_max_overlaps >= conf.fg_thresh); gt_best_matches]);
fg_inds = unique(find(ex_max_overlaps >= conf.fg_thresh));

% the logic for assigning labels to anchors can be satisfied
% by both the positive label and the negative label; when this
% happens, we prioritize the positive label to pursue high recall
bg_inds = setdiff(find(ex_max_overlaps < conf.bg_thresh_hi & ...
    ex_max_overlaps >= conf.bg_thresh_lo), fg_inds);

gray_inds = unique(find( ex_max_overlaps <= conf.gray_hi ...
    & ex_max_overlaps >= conf.gray_lo ));

% if conf.drop_boxes_runoff_image && ~conf.revise_boundary_box
%     contained_in_image_ind = find(contained_in_image);
%     fg_inds = intersect(fg_inds, contained_in_image_ind);
%     bg_inds = intersect(bg_inds, contained_in_image_ind);
% end
% if isempty(bg_inds), keyboard; end

%%
% Find which gt ROI each ex ROI has max overlap with:
% this will be the ex ROI's gt target
target_rois = gt_rois(ex_assignment(fg_inds), :);
src_rois = anchors(fg_inds, :);

gt_info_catch_ind = zeros(size(gt_labels, 1), 1);
gt_info_catch_ind(unique(ex_assignment(fg_inds))) = 1;
gt_info = [gt_info_catch_ind single(gt_labels), gt_rois];

% we predict regression_label which is generated by an un-linear
% transformation from src_rois and target_rois
[regression_label] = fast_rcnn_bbox_transform(src_rois, target_rois);
bbox_targets = -2*ones(size(anchors, 1), 5, 'double');
bbox_targets(fg_inds, :) = [gt_labels(ex_assignment(fg_inds)), regression_label];
bbox_targets(bg_inds, 1) = -1;
bbox_targets(gray_inds, 1) = 0;
end

function contained = is_contain_in_image(boxes, im_size)
    contained = boxes >= 1 & bsxfun(@le, boxes, [im_size(2), im_size(1), im_size(2), im_size(1)]);
    contained = all(contained, 2);
end

function [anchors, check] = refine_box(anchors, im_size)
    anchors(anchors(:, 1) <= 0, 1) = 1;
    anchors(anchors(:, 2) <= 0, 2) = 1;

    anchors(anchors(:, 3) > im_size(2), 3) = im_size(2);
    anchors(anchors(:, 4) > im_size(1), 4) = im_size(1);

    check = all( (anchors(:, 1) < anchors(:, 3) & anchors(:, 2) < anchors(:, 4)), 2 );
    anchors = anchors(check, :);
end